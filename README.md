# lesta_games_interview
**Вопрос №1**. На языке Python написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций.

Пример:

    def isEven(value):
        return value % 2 == 0

Ответ:

    def isEven(value):
        if isinstance(value, int) and value >= 0: 
            return value % 2 == 0
        else: 
            return "Входные данные должны быть положительными и целочисленными"

Интерпретация результатов:
- В функцию добавлен контроль положительности и целочисленности входных данных. Затраты памяти и времени константные - О(1). Возникает ошибка, когда в функцию передается пустой аргумент.

**Вопрос №2**. На языке Python написать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.

Вариант №1:

    class FIFOBuffer:

        # определим атрибуты класса
        def __init__(self, size):
            self.queue: list = [None] * size # очередь
            self.size: int = size # размер очереди
            self.head: int = 0  # индекс первого элемента в очереди
            self.tail: int = 0  # индекс последнего элемента в очереди
            self.count: int = 0  # текущее количество элементов в очереди

        # метод для добавления элементов в очередь
        def add(self, value):
            if self.count >= self.size:
                raise Exception("Очередь переполнена")
            self.queue[self.tail] = value
            self.tail = (self.tail + 1) % self.size
            self.count += 1

        # метод учитывающий элементы из очереди
        def remove(self):
            if self.count == 0:
                raise Exception("Очередь пуста")
            value = self.queue[self.head]
            self.head = (self.head + 1) % self.size
            self.count -= 1
            return value

        # метод, описывающий содержание объекта
        def __repr__(self):
            return f"RingBuffer(size={self.size}, head={self.head}, tail={self.tail}, count={self.count}, queue={self.queue})"

Интерпретация результатов:
 - Оценка быстродействия - О(1), так как нет необходимости сдвигать элементы массива, доступ к элементам получаем за счет двух индексов.

Вариант №2:

    from collections import deque

    class FIFOBuffer:

        # определим атрибуты класса
        def __init__(self, size):
            self.size: int = size
            self.buffer = deque([], maxlen=size)

        # метод для добавления элементов в очередь
        def add(self, value):
            if len(self.buffer) == self.size:
                raise Exception('Очередь переполнена')
            self.buffer.append(value)

        # метод для изъятия элементов из очереди
        def remove(self):
            if len(self.buffer) == 0:
                raise Exception('Очередь пуста')
            return self.buffer.popleft()
    
        # метод, описывающий содержание объекта
        def __repr__(self):
            return f"RingBuffer(size={self.size}, buffer={self.buffer})"
 
Интерпретация результатов:
 - Оценка быстродействия - О(1), такая же как и у предыдущего алгоритма. Эффективность алгоритма обусловлена методами, позволяющими всегда обращаться к первому и последнему элементу списка. По сравнению с предыдущим алгоритмом, код стал более лаконичным и понятным за счет уменьшения количества переменных и строчек кода.


**Вопрос №3**. На языке Python предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.
    
 - Предлагаю использовать алгоритм поразрядной сортировки. Алгоритм сортирует значения разрядов, а не числа целиком, что позволяет избежать многократных "проходов" по массиву и сравнения значений между собой. Отрицательным моментом является, что алгоритм не может определить отсортирован ли массив изначально.

